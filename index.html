<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Covid-19</title>
    <script src="./d3-lasso.min.js"></script>
    <script src="d3.js"></script>
    <style>

        svg {
          font: 10px sans-serif;
        }
        
        
        .bar {
          fill: steelblue;
          clip-path: url(#clip);
        }
          
        .subBar { 
          fill: gray;
          opacity: 0.5;
        }
        
        .axis path,
        .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }
        
        .brush .extent {
          stroke: #fff;
          fill: steelblue;
          fill-opacity: .25;
          shape-rendering: crispEdges;
        }
        
          rect.mover {
                    stroke: red;
                    stroke-opacity: .1;
                    fill: lightSteelBlue;
                    fill-opacity: .5;
                }
        </style>
</head>
<body>
    <div class="body">
        <div class="container_12">
            <div class="grid_1" id="body">
                
            </div>
            <div class="grid_2">
              <input type="text" placeholder="Search Countries" id="filter_countries"/>

                 <ul id="countries-list">

                 </ul>

                <svg id="Map" height="500" width="600"
            >
                    <g id="G"></g>
                </svg>
                
            </div>
            <div class="grid_3">
                <svg id="container" height="500px" width="500px">
                    <g id="body2" style="transform: translate(50px,10px)"></g>
                </svg>
                <div id="tooltip"></div>
            </div>
        </div>
    </div>
</body>
<script>
let store={}
    let x=0
    let y=0
    let k=1
    let deg=0
    let svg=d3.select("#Map")
    div = d3
  .select("body")
  .append("div")
  .attr("class", "tooltip")
  .style("opacity", 0)


  function loadData() {
    return Promise.all([
    d3.csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv', (d, rows, cols) => { 
  
  const dates = cols.slice(4, cols.length);
  const data = [];
    
  dates.forEach((dd, i)=> {
    const match = d['Country/Region'];
    const country = d['Country/Region'];
    const short = d['Country/Region'];
    const region = d['Province/State'];
    const iso = (match !== undefined)?match.iso:'';
    const lat = d['Lat'];
    const lon = d['Long'];
    const date = dd;
    const confirmed = +d[dd];
    const pivot = {
      country: country, short: short, region: region, lat: lat, lon: lon, date: date, confirmed: confirmed, iso: iso
    }
    
    data.push(pivot)
    
  })
  

  return data
 
}),
        d3.json("countries.geo.json")
    ]).then(datasets => {
        
        store.coronadat=datasets[0];
        store.geoJSON = datasets[1];
        return store;
    })
}
//console.log(store)

  function showData() { 

  drawMap(store.geoJSON)
  drawCircles(groupbyCountry(store.coronadat))
  generate_country_list(store.geoJSON)

}

  
    function getMapConfig(){
  let width = 600;
  let height = 550;
  let container=d3.select("#G")
  let zoom = d3.zoom()
       .scaleExtent([1, 40])
       .translateExtent([[0,0], [width, height]])
       .extent([[0, 0], [width, height]])
    .on("zoom",function(){
        zoomed(container)
    })
  

  let containe = d3.select("#Map")
                  .attr("height",height)
                  .attr("width",width)
                  .call(zoom)

  
  return {width, height, container}
}


function zoomed(container)
  {
    x=d3.event.transform.x
    y=d3.event.transform.y
    k=d3.event.transform.k
 
container.attr(
      "transform","translate(" + [d3.event.transform.x, d3.event.transform.y] + ")scale(" + d3.event.transform.k + ")rotate("+deg+",300,150)")
     console.log(x,y,k)
  }

function getMapProjection(config) {
  let {width, height} = config;
  let projection = d3.geoMercator()
  projection.scale(95)
            .translate([width / 2, height / 2 + 100])
            .rotate([0,0,0])
            
  store.mapProjection = projection;
  return projection;
}

function drawBaseMap(container, countries, projection){
  let path =d3.geoPath()
             .projection(projection)
   //console.log(countries)

  container.selectAll("path").data(countries)
      .enter().append("path")
      .attr("d",d=>path(d) )
      .attr("fill", "#fff")
    .attr("stroke", '#bdbdbd')
    .attr("stroke-width", .5)
    .attr("stroke-linejoin", "round")
      .on("mouseenter", function(d) {
         // d3.select(this).attr("fill", "#229a5b")
         div
        .transition()
        .duration(200)
        .style("opacity", .9);
      div
        .html(
            d.properties.name
        )
        .attr("class","tooltip1")
        .style("left", d3.event.pageX + "px")
        .style("top", d3.event.pageY - 28 + "px");
         
        })
      .on("mouseleave",function(){
       // d3.select(this).attr("fill", "#eee")
       div
       .attr("class","tooltip1")
        .transition()
        .duration(500)
        .style("opacity", 0);
       
      })


     
     
      
      
}

function drawMap(geoJeon) {
    let config = getMapConfig();
    let projection = getMapProjection(config)
    drawBaseMap(config.container, geoJeon.features, projection)
}

let myData;
function groupbyCountry(data) {
  //console.log(data)
    confirmedLatest = data.map(d => d[d.length-1]).sort((a,b) => b.confirmed - a.confirmed);
    myData = confirmedLatest;
    //console.log(myData);
    let result = confirmedLatest.reduce((result, d) => {
        //The || sign in the line below means that in case the first option is anything that Javascript consider false (this insclude undefined, null and 0), the second option will be used. Here if result[d.DestAirportID] is false, it means that this is the first time we are seeing the airport, so we will create a new one (second part after ||)
        
        let grpbycounty = result[d.country] || {
            country: d.country,
            short: d.short,
            lat: d.lat,
            lon: d.lon,
            iso: d.iso,
            date: d.date,
            confirmed: 0
        }
        grpbycounty.confirmed += d.confirmed
        result[d.country] = grpbycounty

        return result
    }, {})
    result = Object.keys(result).map(key => result[key])
    //console.log(result)
    drawbar(myData);
    return result;
}

function drawCircles(countrycircle) {
  let config = getMapConfig(); 
  let projection = getMapProjection(config)
  let container = config.container; 
  radius = d3.scaleSqrt([0,d3.max(countrycircle, d=> d.confirmed)], [.5, config.width/40])
  let circles = container.selectAll("circle")
    .data(confirmedLatest)
    .enter()
  .append("circle")
  .attr("class", "confirmed")
    .attr("fill", "#ff9500")
    .attr("fill-opacity", ".15")
    .attr("stroke", "#ff9500")
    .attr("stroke-width", 1)
    .join("circle")
    .attr("transform", d => `translate(${projection([d.lon,d.lat])[0]},${projection([d.lon,d.lat])[1]})`)
    .attr("r", d => radius(d.confirmed))
    .on("mouseenter", function(d) {
         // d3.select(this).attr("fill", "#229a5b")
         div
        .transition()
        .duration(200)
        .style("opacity", .9);
      div
        .html(
          "<b>COUNTRY: </b>" +
            d.country +
            "</br><b>CONFIRMED CASES: </b>" +
          d.confirmed +
            "</br>AS OF " +
          d.date
        )
        .attr("class","tooltip")
        .style("left", d3.event.pageX + "px")
        .style("top", d3.event.pageY - 28 + "px");
         
        })
      .on("mouseleave",function(){
        div
        .attr("class","tooltip")
        .transition()
        .duration(500)
        .style("opacity", 0);
      });

      var lasso_start = function() {
            lasso.items() // reset size
                .classed("not_possible",true)
                .classed("selected",false);
        };

        var lasso_draw = function() {
        
            // Style the possible dots
            lasso.possibleItems()
                .classed("not_possible",false)
                .classed("possible",true);
    
            // Style the not possible dot
            lasso.notPossibleItems()
                .classed("not_possible",true)
                .classed("possible",false)
        };

        var lasso_end = function() {
            // Reset the color of all dots
            lasso.items()
                .classed("not_possible",false)
                .classed("possible",false)
                .classed("isselected",false);

            // Style the selected dots
            lasso.selectedItems()
                .classed("selected",true);
            
            
            

                

        };
        
        var lasso = d3.lasso()
            .closePathSelect(true)
            .closePathDistance(100)
            .items(circles)
            .targetArea(container)
            .on("start",lasso_start)
            .on("draw",lasso_draw)
            .on("end",lasso_end);

        container.call(lasso)
        lasso.items(container.selectAll('circle'))


}

function generate_country_list(data){
  

let countries = [
  
];
for(i of data.features)
{
  countries.push(i.properties.name);
}

ul = document.getElementById("countries-list");

let render_lists = function(lists){
  let li = "";
  for(index in lists){
    li += "<li>" + lists[index] + "</li>";
  }
  ul.innerHTML = li;
}

render_lists(countries);

// lets filters it
input = document.getElementById('filter_countries');

let filterCountries = function(event){
  keyword = input.value.toLowerCase();
  filtered_countries = countries.filter(function(country){
        country = country.toLowerCase();
       return country.indexOf(keyword) > -1; 
  });
  
  render_lists(filtered_countries);
}

input.addEventListener('keyup', filterCountries);
}

loadData().then(showData);

// draw bar chart

function drawbar(data){

      
               
var margin =  {top: 20, right: 10, bottom: 20, left: 50};
var marginOverview = {top: 30, right: 10, bottom: 20, left: 40};
var selectorHeight = 40;
var width = 600 - margin.left - margin.right;
var height = 500 - margin.top - margin.bottom - selectorHeight;
var heightOverview = 80 - marginOverview.top - marginOverview.bottom;
       
var maxLength = d3.max(data.map(function(d){ return d.country.length}))
var barWidth = maxLength * 1.8;
var numBars = Math.round(width/barWidth);
var isScrollDisplayed = barWidth * data.length > width;
       

console.log(isScrollDisplayed)
  
var xscale = d3.scaleBand()
                .domain(data.slice(0,numBars).map(function (d) { return d.country; }))
                .range([0, width])
                .padding(.2);

var yscale = d3.scaleLinear()
							.domain([0, d3.max(data, function (d) { return d.confirmed; })])
              .range([height, 0]);
  
var xAxis  = d3.axisBottom(xscale);
var yAxis  = d3.axisLeft(yscale);
  
var svg = d3.select("#body").append("svg")
						.attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom + selectorHeight);
  
var diagram = svg.append("g")
								 .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  
diagram.append("g")
  		 .attr("class", "x axis")
       .attr("transform", "translate(0, " + height + ")")
       .call(xAxis);
  
diagram.append("g")
       .attr("class", "y axis")
       .call(yAxis);
  
var bars = diagram.append("g");
  
bars.selectAll("rect")
            .data(data.slice(0, numBars), function (d) {return d.country; })
            .enter().append("rect")
            .attr("class", "bar")
            .attr("x", function (d) { return xscale(d.country); })
            .attr("y", function (d) { return yscale(d.confirmed); })
            .attr("width", xscale.bandwidth())
            .attr("height", function (d) { return height - yscale(d.confirmed); })
            .on("click", d=>{
                //console.log(d.country);
                drawline(d.country, store.coronadat)
		    });
  
if (isScrollDisplayed)
{
  var xOverview = d3.scaleBand()
                  .domain(data.map(function (d) { return d.country; }))
                  .range([0, width])
                  .padding(.2);
  yOverview = d3.scaleLinear().range([heightOverview, 0]);
  yOverview.domain(yscale.domain());

  var subBars = diagram.selectAll('.subBar')
      .data(data)

  subBars.enter().append("rect")
      .classed('subBar', true)
      .attr({
          height: function(d) {
              return heightOverview - yOverview(d.confirmed);
          },
          width: function(d) {
              return xOverview.bandwidth()
          },
          x: function(d) {

              return xOverview(d.country);
          },
          y: function(d) {
              return height + heightOverview + yOverview(d.confirmed)
          }
      })

  var displayed = d3.scaleQuantize()
              .domain([0, width])
              .range(d3.range(data.length));

  diagram.append("rect")
              .attr("transform", "translate(0, " + (height + margin.bottom) + ")")
              .attr("class", "mover")
              .attr("x", 0)
              .attr("y", 0)
              .attr("height", selectorHeight)
              .attr("width", Math.round(parseFloat(numBars * width)/data.length))
              .attr("pointer-events", "all")
              .attr("cursor", "ew-resize")
              .call(d3.drag().on("drag", display))
              .on("click", d=>{
                //console.log(d.country);
                drawline(d.country, store.coronadat)
		    });
}
function display () {
    var x = parseInt(d3.select(this).attr("x")),
        nx = x + d3.event.dx,
        w = parseInt(d3.select(this).attr("width")),
        f, nf, new_data, rects;

    if ( nx < 0 || nx + w > width ) return;

    d3.select(this).attr("x", nx);

    f = displayed(x);
    nf = displayed(nx);

    if ( f === nf ) return;

    new_data = data.slice(nf, nf + numBars);

    xscale.domain(new_data.map(function (d) { return d.country; }));
    diagram.select(".x.axis").call(xAxis);

    rects = bars.selectAll("rect")
      .data(new_data, function (d) {return d.country; });

    rects.attr("x", function (d) { return xscale(d.country); });

    rects.enter().append("rect")
      .attr("class", "bar")
      .attr("x", function (d) { return xscale(d.country); })
      .attr("y", function (d) { return yscale(d.confirmed); })
      .attr("width", xscale.bandwidth())
      .attr("height", function (d) { return height - yscale(d.confirmed); });

    rects.exit().remove();
};


}

//end bar


// draw line chart
 function drawline(country, olddata)
 {      console.log(olddata);
        let data = olddata.filter(function(d){
         for(x of d){
            return x.country == country;
         }})[0]
         console.log(data)

         // draw line here

         let body = d3.select("#body2")
document.getElementById("body2").innerHTML="";
	let height = 300;
	let width = 400;

	function showtool(data, coord){ console.log(data)
		d3.select("#tooltip")
			.html("Price: "+data[0]+"<br> Date: "+data[1])
			.style('top', coord[1]-15+"px")
			.style("left", coord[0]+15+"px")
			.style("display", "block")
			.style("color", "blue")
			
	}
	
		data.map(d=> {
            d.date= new Date(d.date)
            d.confirmed = +d.confirmed
		})
		let max = d3.max(data,d=>d.confirmed)
		let yscale = d3.scaleLinear()
		.domain([0,max])
		.range([height,0])
		body.append("g")
		.call(d3.axisLeft(yscale))

		let xscale = d3.scaleTime()
		.domain(d3.extent(data,d=>d.date))
		.range([0,width])
		body.append("g")
		.attr("transform", "translate(0,"+height+")")
        .call(d3.axisBottom(xscale)
          .tickFormat(d3.timeFormat("%d%b")))
	
		var valueline = d3.line()
		.x(d => xscale(d.date))
		.y(d => yscale(d.confirmed))
        .defined(d => !!d.confirmed)
       

	
		/*body.append("path")
		.datum(data)
		.attr("d", valueline)
        .attr("class", "line")*/
        body
        .append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "red")
        .attr("stroke-width", 1.5)
        .attr("d", valueline)
        .attr("class", "line")

         //draw line end
 }
//end line chart


</script>
</html>